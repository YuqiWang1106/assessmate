from django.shortcuts import render, get_object_or_404, redirect
from .models import Course, Team, Assessment, TeamMember, CourseMember, User, AssessmentQuestion, AssessmentResponse
from django.utils.timezone import now
from collections import defaultdict
from django.shortcuts import render
from .models import Course, Team, Assessment
from django.utils.timezone import now
import requests
import urllib.parse
from django.contrib.auth import login
from django.http import HttpResponseForbidden
from .models import User
from django.utils import timezone
import json

GOOGLE_TOKEN_URL = "https://oauth2.googleapis.com/token"
GOOGLE_USERINFO_URL = "https://www.googleapis.com/oauth2/v2/userinfo"
GOOGLE_AUTH_URL = "https://accounts.google.com/o/oauth2/auth"
GOOGLE_REDIRECT_URI = "http://127.0.0.1:8000/accounts/google/callback/"

def google_login(request):
    """Sends user to correct login page, based on selected role"""
    role = request.GET.get("role")
    if role not in ["student", "teacher"]:
        return redirect("landing") # redirect back to landing page if role missing/invalid
    
    # constructs Google OAuth login URL
    params = {
        "client_id": "***REMOVED***",
        "redirect_uri": GOOGLE_REDIRECT_URI,
        "response_type": "code",
        "scope": "openid email profile",
        "state": role,
        "prompt": "select_account",
    }
    return redirect(f"{GOOGLE_AUTH_URL}?{urllib.parse.urlencode(params)}")

def google_callback(request):
    """After successful Google login, retrieves user info and redirects to proper dashboard"""
    code = request.GET.get("code") # gets authorization code from Google's response after successful login
    role = request.GET.get("state") # role from url, created in google_login()

    if not code or not role:
        return redirect("landing")
    
    # authorization code is exchanged to get token ID
    data = {
        "code": code,
        "client_id": "***REMOVED***",
        "client_secret": "***REMOVED***",
        "redirect_uri": GOOGLE_REDIRECT_URI,
        "grant_type": "authorization_code",
    }
    response = requests.post(GOOGLE_TOKEN_URL, data=data)
    token_info = response.json()

    if "id_token" not in token_info:
        return redirect("landing")
    
    # with token ID, can get info on user from Google
    headers = {"Authorization": f"Bearer {token_info['access_token']}"}
    user_info_response = requests.get(GOOGLE_USERINFO_URL, headers=headers)
    user_info = user_info_response.json()

    email = user_info.get("email")
    name = user_info.get("name")

    # ensures only BC emails can have further access
    if not email.endswith("@bc.edu"):
        return HttpResponseForbidden("Please use a @bc.edu email")
    
    # checks if user exists, if not, creates user
    user, created = User.objects.get_or_create(
        email=email,
        defaults={"name": name, "role": role, "created_at": now()},
    )

    # store the user session to restrict access to protected pages -> done in dashboard views
    request.session["user_id"] = str(user.id)
    request.session["user_email"] = user.email
    request.session["user_role"] = user.role

    # redirects user to their respective dashboard
    if user.role == "teacher":
        return redirect("teacher_dashboard", teacher_id=user.id)
    else:
        return redirect("student_courses", user_id=user.id)

def teacher_dashboard(request, teacher_id):
    """Get Teacher Dashboard Data"""
    if "user_id" not in request.session:
        return redirect("landing")

    teacher = get_object_or_404(User, id=teacher_id, role="teacher")
    courses = Course.objects.filter(teacher_id=teacher_id)

    for course in courses:
        Assessment.objects.filter(
            course=course,
            status="published",
            due_date__lt=timezone.now()
        ).update(status="finished")

    # New teacher without any course yet
    if not courses.exists():
            return render(request, "teacher_dashboard.html", {
                "user": teacher,
                "courses": courses,
                "teams_dict": {},  
                "assessments_dict": {},
                "selected_course": None,
                "no_courses": True,
            })

    # Teacher already has at least 1 course
    selected_course_id = request.GET.get("selected_course")
    selected_course = None
    
    if selected_course_id:
        selected_course = courses.filter(id=selected_course_id).first()
        if not selected_course:
            selected_course = courses.first()
    else:
        selected_course = courses.first()
    

    teams_dict = {course.id: list(Team.objects.filter(course=course)) for course in courses}

    assessments_dict = {course.id: list(Assessment.objects.filter(
        course=course,
        status="published", 
        due_date__gte=now()
        ).order_by("due_date")[:4]
        ) for course in courses}


    return render(request, "teacher_dashboard.html", {
        "user": teacher,
        "courses": courses,
        "teams_dict": teams_dict,  
        "assessments_dict": assessments_dict,
        "selected_course": selected_course,
        "no_courses": False, 
    })

def student_courses(request, user_id):
    if "user_id" not in request.session:
        return redirect("landing")

    # Ensure the user exists and is a student
    student = get_object_or_404(User, id=user_id, role="student")

    # Get the courses the student is enrolled in
    course_memberships = CourseMember.objects.filter(user=student)
    courses = [cm.course for cm in course_memberships]
    return render(request, "student_courses.html", {
        "courses": courses,
        "user": student,
    })

def student_dashboard(request, user_id):
    """Render student dashboard based on student ID"""
    if "user_id" not in request.session:
        return redirect("landing")

    # Ensure the user exists and is a student
    student = get_object_or_404(User, id=user_id, role="student")

    # Get the courses the student is enrolled in
    course_memberships = CourseMember.objects.filter(user=student)
    courses = [cm.course for cm in course_memberships]

    # Get teams the student is part of
    teams_dict = {course.id: [] for course in courses}
    for cm in course_memberships:
        team_memberships = TeamMember.objects.filter(course_member=cm)
        teams_dict[cm.course.id] = [tm.team for tm in team_memberships]

    # Get assessments courses
    assessments_dict = {course.id: list(Assessment.objects.filter(course=course)) for course in courses}

    return render(request, "student_dashboard.html", {
        "courses": courses,
        "teams_dict": teams_dict,
        "assessments_dict": assessments_dict,
    })

def landing_page(request):
    return render(request, 'landing_page.html')

def assessment_dashboard(request, teacher_id):
    teacher = get_object_or_404(User, id=teacher_id, role="teacher")
    courses = Course.objects.filter(teacher=teacher)

    selected_course_id = request.GET.get("course_id")
    if selected_course_id:
        selected_course = get_object_or_404(Course, id=selected_course_id, teacher=teacher)
    else:
        selected_course = courses.first()

    overdue_assessments = Assessment.objects.filter(
        course=selected_course,
        status="published",
        due_date__lt=timezone.now()
    )

    for assessment in overdue_assessments:
        assessment.status = "finished"
        assessment.save()

    draft_assessments = Assessment.objects.filter(course=selected_course, status="draft").order_by("-created_at")
    published_assessments = Assessment.objects.filter(course=selected_course, status="published").order_by("due_date")
    finished_assessments = Assessment.objects.filter(course=selected_course, status="finished").order_by("-due_date")

    return render(request, "assessment_dashboard.html", {
        "teacher": teacher,
        "selected_course": selected_course,
        "draft_assessments": draft_assessments,
        "published_assessments": published_assessments,
        "finished_assessments": finished_assessments,
    })

def create_assessment(request, teacher_id, assessment_id=None):
    teacher = get_object_or_404(User, id=teacher_id, role="teacher")

    assessment = None
    questions = []

    if assessment_id:
        assessment = get_object_or_404(Assessment, id=assessment_id, course__teacher=teacher, status="draft")
        questions = AssessmentQuestion.objects.filter(assessment=assessment)

    if request.method == "POST":
        title = request.POST.get("assessment_title", "").strip()
        if not title:
            title = f"Assessment {timezone.now().strftime('%Y-%m-%d %H:%M')}"

        status = "published" if request.POST.get("publish") == "true" else "draft"
        due_date = request.POST.get("due_date")

        if assessment:
            assessment.title = title
            assessment.status = status
            assessment.publish_date = timezone.now() if status == "published" else None
            assessment.due_date = due_date if due_date else None
            assessment.save()
            AssessmentQuestion.objects.filter(assessment=assessment).delete()
        else:
            assessment = Assessment.objects.create(
                course=Course.objects.filter(teacher=teacher).first(),
                title=title,
                status=status,
                publish_date=timezone.now() if status == "published" else None,
                due_date=due_date if due_date else None
            )

        i = 1
        while True:
            text_key = f"question_text_{i}"
            type_key = f"question_type_{i}"
            if text_key not in request.POST:
                break

            AssessmentQuestion.objects.create(
                assessment=assessment,
                question_type=request.POST[type_key],
                content=request.POST[text_key]
            )
            i += 1

        return redirect("assessment_dashboard", teacher_id=teacher.id)

    return render(request, "create_assessment.html", {
        "teacher": teacher,
        "assessment": assessment,
        "questions": questions,
        "questions_json": json.dumps([
        {"question_type": q.question_type, "content": q.content}
        for q in questions
    ])
    })







#settings
TIME_ZONE = "America/New_York"








# urls.py
from django.urls import path
from . import views 

urlpatterns = [
    path("teacher_dashboard/<uuid:teacher_id>/", views.teacher_dashboard, name="teacher_dashboard"),
    path("student_courses/<uuid:user_id>/", views.student_courses, name="student_courses"),
    path("student_dashboard/<uuid:user_id>/", views.student_dashboard, name="student_dashboard"),
    path("", views.landing_page, name="landing"), 
    path("accounts/google/login/", views.google_login, name="google_login"),
    path("accounts/google/callback/", views.google_callback, name="google_callback"),
    path("assessment_dashboard/<uuid:teacher_id>/", views.assessment_dashboard, name="assessment_dashboard"),
    path("create_assessment/<uuid:teacher_id>/", views.create_assessment, name="create_assessment"),
    path("edit_assessment/<uuid:teacher_id>/<uuid:assessment_id>/", views.create_assessment, name="edit_assessment"),

]











